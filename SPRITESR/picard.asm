; PC-6001 MkII (64K) Mode 6
; Picard Demo

ORG 0x9000		; 0x9000 to 0xdfff = 20 KB !!

include "n66sr_bios.asm"

START:
	LD A, 01H
	CALL SCREENPAGE
	CALL SCREENWORK
	CALL SCREENMODE		; SCREEN 2,2,2
	LD C, 9				; Clear color 10 (blue)
	CALL CLEARSCREEN2	; Clears all of screen 2 (slow)
	LD HL, BG_COLOR
	LD C, (HL)			; clear color 2 pixels
	CALL FASTCLEARSCREEN2 ; Clears 256x188 fast work area
	LD C, 0
	CALL CLEARSCREEN2TOP; Clears 256x12 top area (slow)
	LD C, 0
	CALL CLEARSCREEN2RIGHT; Clears 64x265 right area (slow)
						; Draw Frames
	LD BC, 0
	LD DE, 0
	LD A, 3
	LD (0ED81H), A
	LD IX, 319
	LD IY, 199
	LD (0ED82H), IX
	LD (0ED84H), IY
	CALL DRAWBOX		; Draw Box
	LD A, 15
	LD (0ED81H), A
	LD BC, 0
	LD DE, 12
	LD IX, 256
	LD IY, 199
	LD (0ED82H), IX
	LD (0ED84H), IY
	CALL DRAWBOX		; Draw Box 2
PICARD_VSYNC:
						; Set VSYNC event procedure
	CALL SETVSYNCEVENT
PICARD_INIT:
	; Load up test sprite 0 (controllable)
	LD HL, SDTest
	LD (SPRITESR_DATA0), HL
	LD A, 0
	LD (SPRITESR_DATA0+SprX), A
	LD (SPRITESR_DATA0+SprY), A
	LD A, 8
	LD (SPRITESR_DATA0+SprW), A
	LD (SPRITESR_DATA0+SprH), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA0+SprBG), A
	; Sprite 1 (64x64)
	LD HL, SDTest
	LD (SPRITESR_DATA1), HL
	LD A, 64
	LD (SPRITESR_DATA1+SprX), A
	LD (SPRITESR_DATA1+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA1+SprBG), A
	; Sprite 2 (128x48)
	LD HL, SDTest
	LD (SPRITESR_DATA2), HL
	LD A, 128
	LD (SPRITESR_DATA2+SprX), A
	LD A, 48
	LD (SPRITESR_DATA2+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA2+SprBG), A
	; Sprite 3 (48x106)
	LD HL, SDTest
	LD (SPRITESR_DATA3), HL
	LD A, 48
	LD (SPRITESR_DATA3+SprX), A
	LD A, 106
	LD (SPRITESR_DATA3+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA3+SprBG), A
	; Sprite 4 (30x70)
	LD HL, SDTest
	LD (SPRITESR_DATA4), HL
	LD A, 30
	LD (SPRITESR_DATA4+SprX), A
	LD A, 70
	LD (SPRITESR_DATA4+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA4+SprBG), A
	; Sprite 5 (60x130)
	LD HL, SDTest
	LD (SPRITESR_DATA5), HL
	LD A, 60
	LD (SPRITESR_DATA5+SprX), A
	LD A, 130
	LD (SPRITESR_DATA5+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA5+SprBG), A
	; Sprite 6 (200x100)
	LD HL, SDTest
	LD (SPRITESR_DATA6), HL
	LD A, 200
	LD (SPRITESR_DATA6+SprX), A
	LD A, 100
	LD (SPRITESR_DATA6+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA6+SprBG), A
	; Sprite 7 (230x160)
	LD HL, SDTest
	LD (SPRITESR_DATA7), HL
	LD A, 230
	LD (SPRITESR_DATA7+SprX), A
	LD A, 160
	LD (SPRITESR_DATA7+SprY), A
	LD A, (BG_COLOR)
	LD (SPRITESR_DATA7+SprBG), A
PICARD_UPDATE:
	CALL SPRITESR_REDRAWALL
	; Movement timer?
	LD HL, SPRITES_MOVE_TIMER
	LD A, (HL)
	INC A
	LD (HL), A
	LD HL, SPRITES_MOVE_EVERY
	CP (HL)
	JP NZ, PICARD_CHECK_INPUT	; if timer != T: skip to input
	LD A, 0
	LD (SPRITES_MOVE_TIMER), A	; timer = 0
	; Update movement
	LD B, 7
  PICARD_SPRITEMOVEMENT_LOOP:
	LD HL, SPRITES_MOVE_X
	LD A, B
	ADD A, L
	LD L, A
	ADC A, H
	SUB L
	LD H, A			; ADD HL, SPRITES_MOVE_X+B
	EX DE, HL		; DE = SPRITES_MOVE_X+B
	LD H, D
	LD L, E			; HL = SPRITES_MOVE_X+B
	LD A, (HL)		; A = spriteMove[B].x
	OR 0
	JP P, PICARD_SPRITEMOVEMENT_X_POS
	JP M, PICARD_SPRITEMOVEMENT_X_NEG
	JP PICARD_SPRITEMOVEMENT_CHECK_Y
  PICARD_SPRITEMOVEMENT_X_POS:
	LD A, B
	ADD A	; double B to get 16-bit address SPRITES_DATA
	LD HL, SPRITES_DATA
	ADD A, L
	LD L, A
	ADC A, H
	SUB L
	LD H, A			; ADD HL, SPRITES_DATA+B*2
	LD A, (HL)
	INC HL
	LD C, (HL)
	LD L, A
	LD H, C			; LD HL, (HL) as CA
	INC HL
	INC HL			; HL = (SPRITES_DATA+B*2).SprX
	LD A, (HL)		; A = sprites[B].x
	CP 254 - 8		; flags = sprites[B].x - (254-8)?
	JP C, PICARD_SPRITEMOVEMENT_X_POS_LESS 	; x < 254 - 8
	JP PICARD_SPRITEMOVEMENT_X_POS_GE	   	; x >= 254 - 8
  PICARD_SPRITEMOVEMENT_X_POS_LESS:
	; sprites[B].x += 2
	INC (HL)
	INC (HL)
	JP PICARD_SPRITEMOVEMENT_CHECK_Y
  PICARD_SPRITEMOVEMENT_X_POS_GE:   ; moveX = -1
	EX DE, HL		; HL = SPRITES_MOVE_X + B
	LD A, -1
	LD (HL), A		; spriteMove[B].x = -1
	JP PICARD_SPRITEMOVEMENT_CHECK_Y
  PICARD_SPRITEMOVEMENT_X_NEG:
	LD A, B
	ADD A	; double B to get 16-bit address SPRITES_DATA
	LD HL, SPRITES_DATA
	ADD A, L
	LD L, A
	ADC A, H
	SUB L
	LD H, A			; ADD HL, SPRITES_DATA+B*2
	LD A, (HL)
	INC HL
	LD C, (HL)
	LD L, A
	LD H, C			; LD HL, (HL) as CA
	INC HL
	INC HL			; HL = (SPRITES_DATA+B*2).SprX
	LD A, (HL)		; A = sprites[B].x
	OR 0
	JP Z, PICARD_SPRITEMOVEMENT_X_NEG_Z
  PICARD_SPRITEMOVEMENT_X_NEG_NZ:
	; sprites[B].x -= 2
	DEC (HL)
	DEC (HL)
	JP PICARD_SPRITEMOVEMENT_CHECK_Y
  PICARD_SPRITEMOVEMENT_X_NEG_Z:
    ; spriteMove[B].x =  1
	EX DE, HL
	LD A, 1
	LD (HL), A
    ; End of X movement
  PICARD_SPRITEMOVEMENT_CHECK_Y:
	; Beginning of Y movement
	LD HL, SPRITES_MOVE_Y
	LD A, B
	ADD A, L
	LD L, A
	ADC A, H
	SUB L
	LD H, A			; ADD HL, SPRITES_MOVE_Y+B
	EX DE, HL		; DE = SPRITES_MOVE_Y+B
	LD H, D
	LD L, E			; HL = SPRITES_MOVE_Y+B
	LD A, (HL)		; A = spriteMove[B].y
	OR 0
	JP P, PICARD_SPRITEMOVEMENT_Y_POS
	JP M, PICARD_SPRITEMOVEMENT_Y_NEG
	JP PICARD_SPRITEMOVEMENT_END_Y
  PICARD_SPRITEMOVEMENT_Y_POS:
	LD A, B
	ADD A	; double B to get 16-bit address SPRITES_DATA
	LD HL, SPRITES_DATA
	ADD A, L
	LD L, A
	ADC A, H
	SUB L
	LD H, A			; ADD HL, SPRITES_DATA+B*2
	LD A, (HL)
	INC HL
	LD C, (HL)
	LD L, A
	LD H, C			; LD HL, (HL) as CA
	INC HL
	INC HL
	INC HL			; HL = (SPRITES_DATA+B*2).SprY
	LD A, (HL)		; A = sprites[B].y
	CP 187 - 8		; flags = sprites[B].y - (187 - 8)?
	JP C, PICARD_SPRITEMOVEMENT_Y_POS_LESS 	; y < 187 - 8
	JP PICARD_SPRITEMOVEMENT_Y_POS_GE	   	; y >= 187 - 8
  PICARD_SPRITEMOVEMENT_Y_POS_LESS:
	; sprites[B].y += 2
	INC (HL)
	INC (HL)
	JP PICARD_SPRITEMOVEMENT_END_Y
  PICARD_SPRITEMOVEMENT_Y_POS_GE:   ; moveY = -1
	EX DE, HL		; HL = SPRITES_MOVE_Y + B
	LD A, -1
	LD (HL), A		; spriteMove[B].y = -1
	JP PICARD_SPRITEMOVEMENT_END_Y
  PICARD_SPRITEMOVEMENT_Y_NEG:
	LD A, B
	ADD A	; double B to get 16-bit address SPRITES_DATA
	LD HL, SPRITES_DATA
	ADD A, L
	LD L, A
	ADC A, H
	SUB L
	LD H, A			; ADD HL, SPRITES_DATA+B*2
	LD A, (HL)
	INC HL
	LD C, (HL)
	LD L, A
	LD H, C			; LD HL, (HL) as CA
	INC HL
	INC HL
	INC HL			; HL = (SPRITES_DATA+B*2).SprY
	LD A, (HL)		; A = sprites[B].y
	OR 0
	JP Z, PICARD_SPRITEMOVEMENT_Y_NEG_Z
  PICARD_SPRITEMOVEMENT_Y_NEG_NZ:
	; sprites[B].y -= 2
	DEC (HL)
	DEC (HL)
	JP PICARD_SPRITEMOVEMENT_END_Y
  PICARD_SPRITEMOVEMENT_Y_NEG_Z:
    ; spriteMove[B].y =  1
	EX DE, HL
	LD A, 1
	LD (HL), A
	
  PICARD_SPRITEMOVEMENT_END_Y:	
	DEC B
	JP NZ, PICARD_SPRITEMOVEMENT_LOOP ; loop B 7 to 1
	
  PICARD_CHECK_INPUT:
	; Read Input
	CALL MODKEYDOWN
	JP Z, PICARD_UPDATE
	LD B, A
	AND 0b10000000		; Space
	JP NZ, PICARD_END
	LD A, B
	AND 0b00010000		; Right
	JP NZ, PICARD_RIGHT
  PICARD_AFTER_RIGHT:
	LD A, B
	AND 0b00100000		; Left
	JP NZ, PICARD_LEFT
  PICARD_AFTER_LEFT:
	LD A, B
	AND 0b00000100		; Up
	JP NZ, PICARD_UP
  PICARD_AFTER_UP:
	LD A, B
	AND 0b00001000		; Down
	JP NZ, PICARD_DOWN
	JP PICARD_UPDATE
PICARD_RIGHT:
	LD HL, SPRITESR_DATA0+SprX
	INC (HL)
	JP PICARD_AFTER_RIGHT
PICARD_LEFT:
	LD HL, SPRITESR_DATA0+SprX
	DEC (HL)
	JP PICARD_AFTER_LEFT
PICARD_UP:
	LD HL, SPRITESR_DATA0+SprY
	LD A, (HL)
	OR 0
	JP Z, PICARD_AFTER_UP ; dont decrement 0
	DEC (HL)
	JP PICARD_AFTER_UP
PICARD_DOWN:
	LD HL, SPRITESR_DATA0+SprY
	LD A, (HL)
	ADD 255-187+8
	JP C, PICARD_REDRAW
	INC (HL)
	JP PICARD_REDRAW
PICARD_REDRAW:
	JP PICARD_UPDATE
PICARD_END:
	CALL ENDVSYNCEVENT
						; Done
	LD A, 000H
	CALL SCREENPAGE		; Switch to Page 1
	RET					;------------------- END
BG_COLOR:
	DEFB 0x55
SPRITES_MOVE_X:
	DEFB 0, 1, 1, -1, 1, -1, -1, 1
SPRITES_MOVE_Y: 
	DEFB 0, -1, -1, -1, 1, 1, 1, -1
SPRITES_DATA:
	DEFW SPRITESR_DATA0, SPRITESR_DATA1
	DEFW SPRITESR_DATA2, SPRITESR_DATA3
	DEFW SPRITESR_DATA4, SPRITESR_DATA5
	DEFW SPRITESR_DATA6, SPRITESR_DATA7
SPRITES_MOVE_TIMER:
	DEFB 0x0
SPRITES_MOVE_EVERY:
	DEFB 0x10
	
include "vsync.asm"
include "fastclear.asm"
include "spritesr.asm"
include "sprites.asm"
